# Assignment 3

### Alexander Rinsche 12120519

Datasets
---
`HERC03.LAB3.PL1` is created by the job `dataset.jcl` and contains the following members:
- (SAMPDAT): The pl1 code from [[fibonacci.pl1]]
- (SAMPCLG): The jcl code from the assignment
- (TAXREC): The TAXREC record structure

`HERC03.LAB3.DAT1` & `HERC03.LAB3.DAT2`, which are created by SAMPCLG. They contain the old and new taxrecord sets.

`HERC03.LAB3.DAT3` is generated by the taxdiff job. It contains the diff-records with the changes between the two taxrecord sets.


Running the code
---
Make sure you have the mainframe up and running and the ftp daemon running (`/s ftpd` in the main console). 
Run `make all` in the root folder. 
It will run three jobs in the following order and is set up to work with a completely fresh Hercules instance:
- `setup_job`: As a first step the `PL1` dataset will be created, then the files `TAXREC`, `SAMPDAT` and `SAMPCLG` will be copied via ftp into the dataset, and finally, the SAMPCLG program will be run (I didn't bother figuring out how to run a job stored in a dataset from the outside, so I just submitted it directly via the virtual punchcard reader (which hence will be known as VPR) , my favorite tool of the entire mainframe <3, thereby creating the `DAT1` and `DAT2` datasets.
- `taxdiff_job`: This will concatenate the files `job.jcl`, `amogus.pl1` and `job_end.jcl` together and submit it to the VPR. This creates the `DAT3` dataset, and calculates the difference between the taxrecord datasets.
- `readoutput_job`: This is a helper job thats purpose is to read the `DAT3` dataset and write it to `SYSPRINT`. It's to verify that the file-write actually worked (which probably took the most time, even with Györgi's help, which I'm very grateful for).

A final convenience job is the `readinput_job` which just prints the to input datasets together in the same fashion as the `taxdiff_job` reads them. This was meant as a sanity check that my diff code was actually doing what I was hoping it would.

The provided files `job_stats.txt` and `output.txt` contain one run of `make all`, which have been flushed and printed as discussed in the two previous exercises.


Code Explanation
---
I have never faced a language that was so actively discouraging the use of good programming practices as PL1 during this exercise. 
My two favorites:
- Extracting duplicate code into functions or subroutines is generally considered a bad move. Weird scope leak, odd variable shadowing behavior and the frequent issues when passing files and records to subroutines and reassigning them to other variables kept this whole ordeal spicy until the end.
- Writing too many comments is discouraged. Apparently, the compiler doesn't properly escape comments, so I had some fun debugging sessions only to notice that some special character like a `:` was causing the compiler to figuratively shit itself.

The heart of the logic is the file `amogus.pl1`, originally named as a joke but then kept because of the continuous feeling of being stabbed in the back by the mainframe, which is what it has in common with the game "Among us".

The file contains contains a main procedure and two subroutines, and takes three datasets as input: `OLDDAT`, `NEWDAT` and `CHANGES`. 
The subroutines, `AMOGUS` and `DISPLAYREC` are essentially format functions that handle printing CHANGE or TAXREC records. Although they initially contained more logic and I had additional, more sophisticated subroutines, I had to inline most of the code, because of the previously mentioned whims of the compiler.
The main function iterates over OLDDAT and NEWDAT and compares the records it reads. It distinguishes between 3 cases:
- If the taxid from OLDDAT is higher than that of NEWDAT, it will create a CHANGE dataset tagged with a 'A' for added and repeatedly read from NEWDAT until the taxids are equal or the read one is higher.
- The same holds if the taxid from NEWDAT is higher than OLDDAT, except that the CHANGE record will be tagged with a 'D' for deleted.
- If both taxids are equal, the contents (except for NOTES, see Known Issues for more info), are compared. If the fields differ, a CHANGE record tagged 'U' for updated is output. This is also the only case in which flags are set to read the next set of records from both files at once, since in the other cases we only "consumed" one output and immediately read the next entry from the according dataset.

The loop ends as soon as one of the files sends an ENDFILE condition, which is captured in two corresponding `ON` statements and sets EOF_FLAGS.
Afterwards, the EOF_FLAGS of both flags are checked seperately, since after the loop only one file buffer might be empty and remaining entries still have to be cataloged. In case that OLDDAT still contains entries, corresponding 'D'-CHANGE records are created, in case of NEWDAT, 'A'-CHANGE records.


Notes on development
---
#### Editor
After some configuration, development in Neovim was quite convenient. Neovim has a Treesitter parser for pl1, which made syntax highlighting formatting quite convenient. Some additional settings that I added to `after/ftplugin/pli.lua`, that further enriched my experience, were the following:

```lua
-- For filetype "pli" set the following configurations
local set = vim.opt_local
set.shiftwidth = 2
set.expandtab = true
set.textwidth = 80
set.colorcolumn = "1,80"
```
This made indentation more convenient and added some helpful visual markers in column 1 and 80.


#### On the Virtual Punchard Reader
Although it was a far more pleasent experience overall than working within the dreaded mainframe editor, there were two quirks worth noting:
- Negation symbols weren't the esoteric ¬ symbols, but regular ^ carets.
- | are swallowed by the conversion. There probably is a replacement, however I didn't bother searching for it. Instead I used double negation to eliminate ors and in the final version of my code I didn't even need or's at all.



Known issues
---
Differences between solely the Notes segment of two taxrecords will go unnoticed. I tried several things to fix this, but it never worked. COMPARE() seemed to also check the parts after the null byte, because it kept saying that two empty strings were different from one another. Direct comparison via the equality operator also seemed kinda busted, I honestly can't fathom how, why and what I could have done.
